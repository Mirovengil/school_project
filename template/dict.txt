<p>Ассоциативный массив -- структура данных, где каждому элементу соответствует
свой <b>ключ</b>, по которому можно получить этот элемент.</p>
<p>Типичный пример ассоциативного массива -- обыкновенный словарь:</p>
<img src = "img/struct/005.png">
<p>Естественно, ключи и значения могут быть любого типа, который относится 
к базовым: логического, целочисленного, символьного/строкового, вещественного.
Вот ещё один пример: </p>
<img src = "img/struct/006.png">
<p>Важно понимать, что одинаковых ключей быть не может: значение будет
перезаписываться. А вот одинаковых значений может быть сколько угодно:</p>
<p><b>Такое возможно:</b></p>
<img src = "img/struct/007.png">
<p><b>А такое -- нет:</b></p>
<img src = "img/struct/008.png">
<p>В целом, в реализации ассоциативного массива "в лоб" нет ничего сложного.
Конечно, его можно написать, используя хеш-функции, но эта тема явно не
для средней школы. Поэтому мы обойдёмся двумя статическими (динамические в 
средней школе, увы, не проходят) массивами: <b>keys</b> -- массив ключей и
<b>vals</b> -- массив значений; также нам понадобится переменная <b>n</b>, отвечающая за длину
словаря. В языке <b>Python</b> вместо неё мы будем использовать функцию <b>len</b>, чтобы
избежать проблем с передачей целого числа по ссылке. Всё будет несколько примитивно, зато понятно
 -- и написать и использовать вы сможете сами!</p>
<p>Итак, давайте определим минимальный набор функций, обрабатывающих словарь:
<ul>
    <li>Задать значение по ключу</li>
    <li>Удалить элемент</li>
    <li>Узнать, существует ли элемент</li>
    <li>Очистить ассоциативный массив</li>
    <li>Получить значение по ключу</li>
</ul>
</p>
<p>В данном примере мы будем реализовывать словарь где:
<ul>
    <li>Ключ -- строковая переменная;</li>
    <li>Значение -- целочисленная переменная;</li>
</ul>
</p>
<p>Мы имеем два массива <b>keys</b> -- массив ключей и
<b>vals</b> -- массив значений, которые связаны индексами: под ключом <b>keys[i]</b>
хранится значение <b>vals[i]</b>.</p>
<h2>Задать значение по ключу</h2>
<p>Логика работы следующая: если ключ <b>key</b>существует, то надо поменять значение <b>value</b>, которое к нему
привязано. Если ключа ещё нет -- создать ключ <b>key</b> и привязать к нему значение <b>value</b>.</p>
<~c~>
void set(std::string *keys, int *vals, int &n, std::string key, int value)
{
    //Надо пройти по всем элементам ассоциативного массива
    for (int i = 0; i < n; ++i)
        if (keys[i] == key)
        {
            //Если ключ существует
            vals[i] = value;
            return;
        };
    //Если ключа не существует
    vals[n] = value;
    keys[n] = key;
    //Надо не забыть увеличить размер ассоциативного массива
    n += 1;
};
<~/c~>
<h2>Удалить элемент</h2>
<p>Принцип следующий: найти элемент с ключом <b>key</b>, обменять его местами с последним элементом словаря (
который находится в ячейке <b>n</b> - 1) и уменьшить длину ассоциативного массива на один.</p>
<~c~>
void rem(std::string *keys, int *vals, int &n, std::string key)
{
    //Проходим по всем элементам ассоциативного массива
    for (int i = 0; i < n; ++i)
        if (keys[i] == key)
        {
            //Когда находим удаляемый ключ
            int tmp1 = vals[i];
            vals[i] = vals[n - 1];
            vals[n - 1] = tmp1;
            //Меняем местами vals[i] и vals[n-1]
            std::string tmp2 = keys[i];
            keys[i] = keys[n - 1];
            keys[n - 1] = tmp2;
            //Меняем местами keys[i] и keys[n-1]
            //И не забываем уменьшить длину ассоциативного массива:
            n -= 1;
            return;
        };
};
<~/c~>

<h2>Узнать, существует ли ключ</h2>
<p>Надо пройти по ассоциативному массиву, сравнивая все ключи с искомым <b>key</b>. Совпадают -- вернуть
истину. Если по выходе из массива функция ещё не вернула истину, то такой ключ в массиве отсутствует.
Следовательно, надо вернуть ложь.</p>
<~c~>
bool exist(std::string *keys, int n, std::string key)
{
    for (int i = 0; i < n; ++i)
        if (keys[i] == key)
            return true;
    return false;
};
<~/c~>

<h2>Очистить ассоциативный массив</h2>
<p>Тут всё просто. Надо установить длину массива в ноль.</p>
<~c~>
void clear(int &n)
{
    n = 0;
};
<~/c~>


<h2>Получить значение по ключу</h2>
<p>Надо пройти по массиву ключей. Если встретится совпадающий с искомым <b>key</b>, то надо
вернуть значение под этим ключом. Если по выходе из цикла по массиву функция ещё не завершилась,
то, очевидно, такого ключа не существует. В этом случае вы реализуем аварийный выход.</p>

<~c~>
int get(std::string *keys, int *vals, int n, std::string key)
{
    for (int i = 0; i < n; ++i)
        if (keys[i] == key)
            return vals[i];
    //Если ключ не был найден, то аварийно завершим функцию.
    exit(1);
};
<~/c~>

<h2>Пример использования</h2>
<~c~>
//Очистка ассоциативного массива
clear(n);

//Добавление нескольких пар "ключ-значение"
set(keys, vals, n, "Ivan", 213);
set(keys, vals, n, "Anton", 21);
set(keys, vals, n, "Egor", 321);

//Замена значения для одного из ключей
set(keys, vals, n, "Ivan", 1234);

//Проверка на существования ключа (вернёт истину)
std::cout << "\nIvan:" << exist(keys, n, "Ivan") << "\n";

//Получение значения по ключу
std::cout << get(keys, vals, n, "Ivan");    

//Удаление ключей из ассоциативного массива
rem(keys, vals, n, "Ivan");
rem(keys, vals, n, "Egor");
rem(keys, vals, n, "Anton  ");

//Повторное удаление ключа не "уронит" программу
rem(keys, vals, n, "Ivan");

//Проверка на существования ключа (вернёт ложь)
std::cout << "\nIvan:" << exist(keys, n, "Ivan");
<~/c~>

<p>Итак, как вы видите, написать на каком-либо языке ассоциативный массив
не представляет особой трудности, а для решения немалого количества задач
он является очень удобной структурой данных!</p>

<a href="./struct.html" class = "btn">Структуры данных</a>
