<p>В данном разделе будет рассматриваться сдвиг всего массива с созданием нового, куда будет производиться копирование.
Если вам нужно выполнить сдвиг внутри одного массива, то рекомендуется посетить страницу "Сдвиг части массива".</p>
<a href = "./sdwig_part_of_array.html" class = "btn">Сдвиг части массива</a>
<p>Итак, сдвиг массива c использованием второго массива. Его предпочтительно делать в цикле, вычисляя для каждого элемента его новую позицию. Казалось бы,
что может быть проще? Просто прибавить к старому индексу некоторое значение. </p>
<p>Пусть <b>i</b> - индекс элемента в старом массиве, <b>new_i</b> - индекс этого же элемента в новом массиве, а <b>move</b> - на сколько
надо сдвинуть элемент. Тогда, казалось бы</p>
<p class = "lang">C++</p>
<pre><code class = "C++">
    new_i = i + move;
</code></pre>
<p class = "lang">Pascal</p>
<pre><code class = "pascal">
    new_i := i + move;
</code></pre>
<p class = "lang">Python</p>
<pre><code class = "Python">
    new_i = i + move
</code></pre>
<p>Но что будет, если i + move больше, чем размер массива? Тогда отсчёт продолжится с начала массива:</p>
<img src = "./img/arrays/001.png">
<p>А в описанной выше реализации произойдёт выход за границу массива. Что делать?</p>
<p>Вопрос "на засыпку": какая операция позволяет
превратить индекс, равный индексу последнего элемента плюс один, т.е., равный длине массива, в ноль?</p>
<p>Ответ: остаток от деления!</p>
<p>Получается такой код (пусть <b>n</b> - длина массива)</p>
<p class = "lang">C++</p>
<pre><code class = "C++">
    new_i = (i + move) % n;
</code></pre>
<p class = "lang">Pascal</p>
<pre><code class = "pascal">
    new_i := (i + move) <b>mod</b> n;
</code></pre>
<p class = "lang">Python</p>
<pre><code class = "Python">
    new_i = (i + move) % n
</code></pre>
<p>Эта реализация обрабатывает также случай, когда сдвиг больше длины массива, т.к. остаток от деления гарантирует, что new_i < n.</p>
<p>Казалось бы, код готов. Но, как гласит анекдот, есть один нюанс. Что будет, если сдвиг идёт не вправо? Правильно,
он будет иметь отрицательный размер. В принципе, в этом нет ничего страшного. Но теперь могут появиться отрицательные индексы,
которые не дружат с большинством языков. Должно произойти следущее:</p>
<img src = "./img/arrays/002.png">
<p>Снова вопрос "от Жака Фреско": как превратить индекс, равный минус одному, в индекс, равный n-1, т.е, в последний
индекс массива? Правильно, прибавить n. (если кто-то не в силах посчитать, то -1 + n = n - 1)</p>
<p class = "lang">C++</p>
<pre><code class = "C++">
    new_i = (i + move + n) % n;
</code></pre>
<p class = "lang">Pascal</p>
<pre><code class = "pascal">
    new_i := (i + move + n) <b>mod</b> n;
</code></pre>
<p class = "lang">Python</p>
<pre><code class = "Python">
    new_i = (i + move + n) % n
</code></pre>
<p>Реализация подсчёта индекса почти завершена. Если i + move + n >= 0, то всё работает корректно. Осталось обработать только один случай:
что будет, если сдвиг отрицателен и его размер по модулю больше n? Тогда опять получится отрицательное число. Самый простой способ обработать
этот случай - сделать move меньшим, чем n.</p>
<p>Вопрос: какая операция позволяет это сделать?</p>
<p>Ответ: остаток от деления! Надо применить его к сдвигу. Получается такой код:</p>
<p class = "lang">C++</p>
<pre><code class = "C++">
    move = move % n;<br>
    new_i = (i + move + n) % n;
</code></pre>
<p class = "lang">Pascal</p>
<pre><code class = "pascal">
    move := move <b>mod</b> n;<br>
    new_i := (i + move + n) <b>mod</b> n;
</code></pre>
<p class = "lang">Python</p>
<pre><code class = "Python">
    move = move % n<br>
    new_i = (i + move + n) % n
</code></pre>
<p>Отлично, вычисление нового индекса написано! И написано весьма красиво: нет ни одного условного оператора.</p>
<p>Теперь дело за малым: встроить сие чудо в цикл, обрабатывающий массив (пусть <b>arr1</b> -- первый массив, а 
<b>arr2</b> -- второй):</p>
<p class = "lang">C++</p>
<pre><code class = "C++">
    move = move % n;<br>
    for (int i = 0; i < n; ++i)<br>
    {<br>
    <~tab~>int new_i = (i + move + n) % n;<br>
    <~tab~>arr2[new_i] = arr1[i];<br>
    };
</code></pre>
<p class = "lang">Pascal</p>
<pre><code class = "pascal">
    move := move <b>mod</b> n;<br>
    for i := 0 to n - 1 do<br>
    begin<br>
    <~tab~>new_i := (i + move + n) <b>mod</b> n;<br>
    <~tab~>arr2[new_i] := arr1[i];<br>
    end;<br>
</code></pre>
<p class = "lang">Python</p>
<pre><code class = "Python">
    move = move % n<br>
    for i in range(n):<br>
    <~tab~>new_i = (i + move + n) % n<br>
    <~tab~>arr2[new_i] = arr1[i]<br>
</code></pre>    
<p>Есть два важных нюанса в использовании этого алгоритма. Во-первых, выполнять деление сдвига с остатком
следует вне цикла, чтобы не совершать лишних операций. Во-вторвых, рекомендуется использовать (и вообще во всех
алгоритмах на языке Pascal) стандартную индексацию массива: это избавляет от многих сложностей.</p>
<a href="./arrays.html" class = "readdr">Массивы</a>
