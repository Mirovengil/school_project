<p>Бинарный поиск по ответу относится к разряду алгоритмов, которые подходят для решения многих задач, и часто
встречается на всевозможного рода олимпиадах (говорю, как человек, который его часто писал на конкурсах). Существуют
задачи или просто ситуации, когда необходимо вывести какую-нибудь формулу. Формула может быть сложной. Специально для тех,
кому лень думать над выведением формулы, существует бинарный поиск по ответу. Если вы хотите узнать, как при помощи бинарного
поиска быстро найти элемент в массиве, то посетите соответствующую страницу: </p>
<a href = "./bin_array_find.html" class = "btn">Бинарный поиск по массиву</a>
<p>А мы пока продолжим разговор об использовании бинарного поиска в качестве замены выведению формулы. Давайте сперва
рассмотрим идею его работы. Важно отметить, что работает этот алгоритм только на монотонных функциях: т.е, если вы увеличиваете
аргумент, то значение увеличивается, уменьшаете аргумент -- уменьшается и значение. Рассмотрим пример такой функции:</p>
<img src = "img/based/005.png">
<p>Пусть нам надо подобрать такой х, чтобы у был равен выделенному красной линией. Рассмотрим промежуток (<b>left</b>, <b>right</b>), на котором
определена функция:</p>
<img src = "img/based/006.png">
<p>Значение по у, как уже было сказано, нам известно. Надо подобрать такой х, чтобы f(x) = y. Давайте возьмём среднее между left и right
значение и обозначим его за m:</p>
<img src = "img/based/007.png">
<p>Мы видим, что f(m) меньше, чем искомый y. А т.к. функция монотонна и возрастает, то при x <= m гарантированно f(x) < искомое_значение. 
Следовательно, рассматривать аргументы меньшие, чем m, не имеет смысла. Следовательно, мы имеем дело с промежутком (m; right). Пусть тогда
left = m:</p>
<img src = "img/based/008.png">
<p>Теперь мы повторяем описанные выше шаги:</p>
<img src = "img/based/009.png">
<p>И снова f(m) меньше искомого значения:</p>
<img src = "img/based/010.png">
<p>Продолжаем выполнение алгоритма:</p>
<img src = "img/based/011.png">
<p>f(m) совпало с искомым у! Но мы не останавливаем алгоритм, а продолжаем его 
выполнение (потому что он должен универсальным, а ещё эта реализация повышает точность). Так как рассматривать значения аргумента большие, 
чем m, не имеет смысла, то новый промежуток поиска будет (left; m). Иначе говоря, right = m: </p>
<img src = "img/based/012.png">
<p>Выполнение алгоритма следует продолжать до тех пор, пока right и left не сойдутся в одну полоску:</p>
<img src = "img/based/013.png">
<p>Значение right или left тогда и будет исходным x. Реализация же этого алгоритма имеет некоторые нюансы, хотя и кажется несложной. 
Нюанс заключается в следующем: т.к. между left и right постоянно берётся среднее значение, то right никогда не будет равен left с абсолютной
точностью. Значит, нужно сравнивать их приближённо. К примеру, возьмём точность ответа в шесть знаков после запятой. Тогда погрешность в 0.000001 
не имеет значения. Следовательно, right - left меньше, чем 0.000001.</p> 
<p>Пусть функция определена на промежутке (<b>a</b>; <b>b</b>), а искомый у обозначен как <b>y</b>. Код выглядит следующим образом:</p>
<p  class = "lang">C++</p>
<pre><code class = "C++">
double left = a; //Определение промежутка<br>
double right = b; //Обратите внимание: работа ведётся в вещественных числах<br>
while (right - left > 0.000001)<br>
{<br>
<~tab~> double m = (left + right) / 2;<br>
<~tab~> if (m > y) //Если f(m) больше искомого, то рассматривать значения большие, чем m, не имеет смысла<br>
<~tab~><~tab~>right = m;<br>
<~tab~>else //В противном случае рассматривать значения меньшие, чем m, не имеет смысла<br>
<~tab~><~tab~>left = m;<br>
};
</code></pre>
<p  class = "lang">Pascal</p>
<pre><code class = "pascal">
left := a; {Определение промежутка}<br>
right := b; {Обратите внимание: работа ведётся в вещественных числах}<br>
while (right - left > 0.000001) do<br>
begin<br>
<~tab~> m := (left + right) / 2;<br>
<~tab~> if (m > y) then {Если f(m) больше искомого, то рассматривать значения большие, чем m, не имеет смысла}<br>
<~tab~><~tab~>right := m<br>
<~tab~>else {В противном случае рассматривать значения меньшие, чем m, не имеет смысла}<br>
<~tab~><~tab~>left := m;<br>
end;
</code></pre>
<p  class = "lang">Python</p>
<pre><code class = "Python">
left = a #Определение промежутка<br>
right = b #Обратите внимание: работа ведётся в вещественных числах<br>
while right - left > 0.000001:<br>
<~tab~> m = (left + right) / 2<br>
<~tab~> if (m > y): #Если f(m) больше искомого, то рассматривать значения большие, чем m, не имеет смысла<br>
<~tab~><~tab~>right = m<br>
<~tab~>else: #В противном случае рассматривать значения меньшие, чем m, не имеет смысла<br>
<~tab~><~tab~>left = m<br>
</code></pre>
<p>Т.к. разница между <b>left</b> и <b>right</b> равна погрешности измерения, то результат хранится и в <b>left</b>, и в <b>right</b>.
Для максимальной точности вычислений можете взять среднее между ними.</p>
<a href="./based.html" class = "readdr">Базовые алгоритмы</a>
