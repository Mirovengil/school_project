<p>Стек -- структура данных, которая достаточно часто используется для реализации 
различных алгоритмов. Самый частый пример его использования -- реализация
"истории", которая хранит действия от последнего к первому и с помощью которой
можно совершать "откаты" на определённое количество шагов назад. Такая "история"
есть в любом редакторе, а реализовать её проще всего через стек.</p>
<p>В большинстве современных языков стек реализован внутренними средствами, 
однако очень важно понимать, как он работает, поэтому -- давайте напишем его самостоятельно!</p>
<p>Для реализации стека сперва неплохо бы понять, что он из себя представляет. Это есть структура
данных, реализующая принцип <b>LIFO</b> -- <b>L</b>ast <b>I</b>n <b>F</b>irst <b>O</b>ut.
Если перевести с импортного на русский, то получится что-то вроде <i>Последний Вошёл -- Первый Вышел</i>.
То есть, при запросе на получение элемента из стека вы получите тот, который был добавлен в стек последним.</p>
<p>Возможно, кажется сложным, поэтому давайте рассмотрим на простом и наглядном примере:</p>
<img src = "img/struct/001.png">
<img src = "img/struct/002.png">
<img src = "img/struct/003.png">
<img src = "img/struct/004.png">
<img src = "img/struct/003.png">
<img src = "img/struct/004.png">
<p>Стопка тарелок или книг -- чем не пример стека? Чтобы достать что-то снизу, необходимо сперва поднять
верхнюю, иначе вас постигнет судьба Вицина из "Операции Ы". Важно: <b>при обращении за элементом, стек
всегда вернёт тот, который был добавлен последним!!</b></p>
<p>В принципе, в написании стека нет ничего сложного. Мы будем использовать статические массивы 
(так как динамические в языках-гигантах очень разнятся по быстродействию и удобству, а статические
почти везде одинаковы) и функции с переменными (так как ООП отсутствует в программах 7-9 классов)
для реализации стека. Да, она будет весьма примитивной. Зато своя и понятная!</p>
<p>Итак, поехали. Мы будем использовать массив <b>arr</b> для хранения данных стека и целочисленную
переменную <b>length</b> для хранения текущей длины стека.</p>
<p>Базовый стек должен уметь совершать следующие операции:
<ul>
    <li>Очистка стека;</li>
    <li>Добавление элемента в стек</li>
    <li>Получение последнего элемента из стека</li>
    <li>Удаление последнего элемента из стека</li>
</ul>
</p>
<h2>Очистка стека</h2>
<~c~>
void clear(int &length)
{
    length = 0;
};
<~/c~>
<~pa~>
procedure clean(var length : integer);
begin
    length := 0;
end;
<~/pa~>
<p>К сожалению, функции в языке Python не могут изменять параметры, которые не являются
сложными элементами (массивом, словарём, множеством и т.п.), поэтому будем использовать
более банальные методы:</p>
<~py~>
length = 0 #Обнуление стека
<~/py~>
<h2>Добавление нового элемента в стек</h2>
<p>Первый элемент в массиве лежит в ячейке с индексом ноль. Изначальная длина стека -- ноль.
Следовательно, надо <b>сначала</b> "положить" элемент в последнюю ячейку стека, а потом уже 
увеличить длину стека:</p>
<~c~>
void add(int *mass, int &length, int value)
{
    arr[length] = value;
    length += 1;
};
<~/c~>
<~pa~>
procedure add(var arr : array [0..N] of integer, var length : integer, value : integer);
begin
    arr[length] := value;
    length := length + 1;
end;
<~/pa~>
<p>Python же опять доставляет неудобство тем, что целое число нельзя передать по ссылке:</p>
<~py~>
def add(arr, length, value):
    arr[length] = value
    length = length + 1
    return length
<~/py~>
<p>Соответственно, использовать её придётся немного по-другому (далее будут примеры).</p>
<h2>Получение последнего элемента из стека</h2>
<p>Мы знаем, что длина стека <b>length</b> всегда на единицу больше, чем номер последнего элемента
в нём (это следует из реализации функции <b>add</b>). Следовательно, последний элемент хранится в ячейке 
<b>arr</b> под индексом <b>length</b> - 1. Но важно не забыть проверку, что <b>length</b> > 0. Если
<b>length</b> равно нулю, то элементов в стеке нет -- надо вернуть левое значение/ноль/исключение/что-то ещё:</p>
<~c~>
int get(int *arr, int length)
{
    if (length == 0)
        exit(1); //Аварийный выход из функции
    return arr[length - 1];
}; 
<~/c~>
<~pa~>
function get(arr : array [0..N] of integer, var length : integer) : integer;
{
    if (length == 0) then
        exit(1); {Аварийный выход из функции}
    get := arr[length - 1];
}; 
<~/pa~>
<~py~>
def get(arr, length):
    if length == 0:
        raise ValueError('Стек пуст!') #Аварийный выход из функции
    return arr[length - 1]
<~/py~>
<h2>Удаление последнего элемента из стека</h2>
<p>Чтобы удалить элемент из стека, достаточно просто уменьшить его длину на один.
Но нельзя забывать, что длина стека не может быть меньше нуля:</p>
<~c~>
void del(int &length)
{
    length -= 1;
    if (length < 0)
        length = 0;
};
<~/c~>
<~pa~>
procedure del(var length : integer);
begin    
    length := length - 1;
    if (length < 0) then
        length := 0;
end;
<~/pa~>
<p>Python же опять доставляет неудобство тем, что целое число нельзя передать по ссылке:</p>
<~py~>
def del(length):
    length -= 1
    if length < 0:
        length = 0
    return length
<~/py~>
<h2>Пример использования</h2>
<p>Мы покажем следующий пример: добавить в стек числа 1, 2 и 3 и поочерёдно их извлечь, выводя на экран:</p
<~c~>
clear(length);
add(mass, length, 1);
add(mass, length, 2);
add(mass, length, 3);
for (int i = 0; i < 3; ++i)
{
    std::cout << get(mass, length) << " ";
    del(length);
};
<~/c~>
<~pa~>
clear(length);
add(mass, length, 1);
add(mass, length, 2);
add(mass, length, 3);
for i := 1 to 3 do
begin
    print(get(mass, length), ' ');
    del(length);
end;
<~/pa~>
<~py~>
length = 0
length = add(mass, length, 1)
length = add(mass, length, 2)
length = add(mass, length, 3)
for i in range(0, 3):
    print(get(mass, length), end = ' ');
    length = del(length)
<~/py~>
<p>Поздравляю! У вас есть стек. И пускай он несколько примитивен, зато 
написан своими руками.</p>
<a href="./struct.html" class = "btn">Структуры данных</a>
